算法源码见附件
分享一个去年逆的一个海外版某音 1474版本 x-gorgon算法，这里简单介绍一下算法原理，首先malloc出来一个0x1A大小的空间，然后截取用户传入的byte数组中的参数，截取开始的几个字节，中间的几个字节，最后的几个字节，版本号等，还有几个固定的字节，不同版本不一样，一共26个字节写入到上面malloc出来的地址中，由于开头4个字节都是固定的04010000,0000是正常的设备，如果被检测到就是其他数字，我测试的手机被检测到所以是1081，从第五个字节开始计算，首先按照顺序初始化一个0x00-0xFF的256长度的码表，然后取malloc出来的地址的最低位用于初始化一个8个长度的byte字节数组，其中第四个字节的值取malloc地址 右移8位取最低位，数组最后一个值直接取malloc的地址的最低位，然后开始第一次计算，首先循环遍历256码表，每次从0到7取那8个长度的byte字节数组 一直到256码表循环完为止 根据计算打乱256码表的值，这是第一次计算

 
第二次计算开始循环取那20个参数字节(04010000之外的)进行计算，从256码表的第2个索引值开始取出来 根据加法 取其他索引的值，然后异或运算以后得到第一个结果值写入，一直循环0x14次，循环完以后最开始的字节又会反转 然后跟相邻字节异或得到一个新的值

 
第三次计算又是遍历修改后的那20个字节重新赋值，先取第一个值出来经过右移、异或、取反、与相邻的字节再异或等得到最终的第一个值，第二个第三个重复以上步骤直到最后一个字节因为没有相邻的了，所以跟第一个字节异或得到最后一个字节的最终值

 
补充：0401后面的两个字节，第一个字节取malloc地址最低位，第二个字节取malloc地址 右移8位取最低位

 
一句话解释就是xg值的计算结果都是由malloc出来的地址来决定的，所以每次都不一样

![image](https://user-images.githubusercontent.com/26925472/194685773-bbfbe8ea-a1e7-4356-b098-979caa2a9cd1.png)
![image](https://user-images.githubusercontent.com/26925472/194685778-6f45cbbe-b584-4aeb-9021-a715daf7c38b.png)
![image](https://user-images.githubusercontent.com/26925472/194685787-2407c374-254a-4071-a295-d4dd3cf9ca2c.png)
![image](https://user-images.githubusercontent.com/26925472/194685962-2ab800b6-d3bb-441d-8445-0ac068f6aa93.png)

QQ群：976295816
讨论软件开发和软件逆向的问题欢迎加群交流
